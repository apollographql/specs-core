<!doctype html>
<script src=/boot.js></script>
<title>Using Specifications</title>

<div id=view>
<main markdown>
<header>
  <h1 markdown>The `@using` Directive</h1>
  <h2>for declaring specifications used by a schema</h2>

  <table class=spec-md>
    <tr>
      <td>status</td>
      <td id=spec-md-status>Draft</dd>
    </tr>
    <tr>
      <td>version</td>
      <td id=spec-md-version>0.1</dd>
    </tr>
    <tr>
      <td>authors</td>
      <td id=spec-md-authors>
        <ul class=spec-authors-list>
          <li><a rel=author href=mailto:ashi@apollographql.com>Ashi Krishnan</a>
        </ul>
      </td>
    </tr>
  </table>
</header>

## Problem

Some specificationsâ€”such as the [federation specification](../federation-spec) and [CSDL specification](./csdl)â€”apply to GraphQL schema documents. They may place additional requirements on conforming documents. Such specifications may also introduce new types, directives, and other schema objects which can be used within those documents.

The [GraphQL Schema Definition Language](https://spec.graphql.org/) does not provide a way to declare that a schema document implements additional specs beyond the GraphQL SDL. Currently, this information is derived from context, or through some explicit, out-of-document paramenter provided to a spec processor. As a consequence, given only the text of an SDL document, there is no reliable way to discern what specificationsâ€”and what version of those specificationsâ€”the document conforms to.

This specification provides a solution in the form of a single new well-known directiveâ€”the `@using` directive. This directive allows spec authors, schema authors, and schema processors to come to an agreement on which specifications a schema document is using.

## Actors

```mermaid
#::[Actors who may be interested in the `@using` directive]
graph TB
  author("ðŸ‘©ðŸ½â€ðŸ’» ðŸ¤–  &nbsp;Author")-->schema(["ðŸ“„  Schema"])
  schema-->proc("ðŸ¤– &nbsp;Processor")
  schema-->reader("ðŸ‘©ðŸ½â€ðŸ’»  Reader")
  proc-->output(["ðŸ“„  Output Schema"])
```

- **Authors (either human or machine)** write one or more `@using` directives into schema files to declare that the schema conforms to some set of specifications
- **Machine processors** read the `@using` directives and compare them to a list of supported specs, activating the spec-mandated appropriate behaviors. Processors generally *pass through* schema elements they do not understand, although they may remove them or fail entirely, depending on the processor's needs and the spec's [listed purpose](#for).
- **Human readers** see the `@using` directives and can follow the URLs to the specification, receiving an explanation of the requirements of the specification and what new directives, types, and other schema objects are available within the document.


## The `@using` directive

```graphql
#::[Declaration of the `@using` directive]
directive @using(spec: String!, prefix: String, for: [String])
  repeatable on SCHEMA
```

### `@using` within a document

The `@using` directive is applied to `schema` declarations to declare that the schema uses a particular spec. For example,

```graphql
#::[Using the `@using` directive]
schema @using(spec: "https://spec.example.com/example/v1") {
  query: Query
}
```

### `spec`

Provide the specification URL as a string.

The `spec` argument **should** be the URL of a specification. When viewed, the URL **should** provide the content of the appropriate version of the specification in some human-readable form. In short, a human reader should be able to click the link and go to the docs. It is not required that the content be machine-readable in any particular way.

Processors **must** degrade gracefully. Specifically, if the `spec` argument is not a [valid RFC 3986 URL](https://tools.ietf.org/html/rfc3986), processors **must** treat it as an opaque, non-versioned identifier referencing a particular specification.

The final component of the URL's `"/"`-separated `path` **must** be a valid [SemVer specifier](#semver-specifiers) identifying the version of the spec in use. Everything prior to the version specifier is the spec's *base URL*.

Specifications **should** prefix any schema elements they introduce. The final component of the *base URL*'s `"/"`-separated `path` **should** be the default prefix under which new schema elements will be introduced. For example:

```graphql
#::[Using the `@using` directive with a default prefix]
#                    |---------- ðŸ‘‡ðŸ½ base url --------|ðŸ‘‡ðŸ½ version
schema @using(spec: "https://spec.example.com/example/v1") {
#                                        prefix â˜ðŸ¾
  query: Query
}

type User {
               # prefixed directive from the example spec
  name: String @example_someDirective
}
```

Processors **should** otherwise treat the spec's base URL as an opaque string identifying the specification.

This spec assigns no meaning to additional URL components, such as the query string or fragment. Processors **should** ignore any meaningless URL components when parsing the base URL and semver specifier.

### `prefix`

Change the prefix for schema elements from this specification.

```graphql
#::[Using the `@using` directive with a custom prefix]
schema @using(spec: "https://spec.example.com/example/v1", prefix: "eg") {
  query: Query
}

type User {
  name: String @eg_someDirective
}
```

### `for`

Describe the purpose of a spec within a document.

```graphql
schema @using(spec: "https://example.com/spec/policy/v1",
               for: ["execution", "security"]) {
  ...
}
```

Documents reference specifications for a variety of purposes: to provide documentation, security policies, routing configuration, and so on. This argument describes *why* a spec is being imported. Consumers **may** choose to reject schemas which use unknown specs `for` important purposes. For example, a graph router may decide to fail if presented with a schema that uses an unknown spec `for: ["security"]`.

If specified, `for` must be a list of `String`s. Each item must be either:

1. One of these well-known values:
  - `security` â€” metadata necessary to use the document securely. Processors which are responsible for executing operations **should** fail if asked to process a document which uses an unknown spec `for` `"security"`.
  - `execution` â€” metadata necessary to resolve fields. Processors which are responsible for executing operations **should** fail if asked to process a document which uses an unknown spec `for` `"execution"`.
  - `performance` â€” metadata to improve performance: optimization hints, pre-computed plans, etc.
  - `observation` - annotations for tracing and analytics
  - `documentation` â€” documentation, such as `@todo` and `@deprecated`
2. A custom value with a `_`-separated prefix. E.g. `vendor_serviceDiscovery`, `devMode_editing`

### Requiring `@using` within a spec

Specifications **may** include the following language to instruct schema authors to use `@using` to indicate documents which are intended to conform to the specification:

> SPEC_NAME schema documents **must**/**should**/**may** have a `schema` declaration with a [`@using` directive](/using/drafts/pre-0)
> and the specification URL `SPEC_URL`:
>
> ```graphql
> schema @using(spec: SPEC_URL) {
>   query: Query
> }
> ```

`SPEC_NAME` and `SPEC_URL` should be replaced with the names and URLs for the specification. For example:

> Example Spec schema documents **must** have a `schema` declaration with a [`@using` directive](/using/drafts/pre-0)
> and the specification URL `https://specs.example.com/example/v1`:
>
> ```graphql
> schema @using(spec: "https://specs.example.com/example/v1") {
>   query: Query
> }
> ```

## Processing Schemas

```mermaid
#::[Example processing pipeline]
graph LR
  schema(["ðŸ“„  Input Schema"]):::file-->proc("ðŸ¤– &nbsp;Processor")
  proc-->output(["ðŸ“„  Output Schema"]):::file
  classDef file fill:none,color:#eee;
  style proc fill:none,stroke:fuchsia,color:fuchsia;
```

A common case is that of a processor which consumes an input schema and generates an output schema.

The general guidance for processor behavior is: don't react to what you don't understand.

Specifically, processors:
  - **should** pass through `@using` directives which reference unknown spec URLs
  - **should** pass through unknown directives, types, and other schema elements
  - **should** ignore meaningless URL components (such as unknown query parameters or fragments) within `@using` URLs

An exception to this is processors which prepare the schema for final public consumption. Such processors **may** choose to eliminate all unknown directives and prefixed types in order to hide schema implementation details within the published schema. This will impair the operation of tooling which relies on these directivesâ€”such tools will not be able to run on the output schema, so the benefits and costs of this kind of information hiding should be weighed carefully on a case-by-case basis.


```graphql
#::[`@using` directive with a query string]
schema
  @using(spec: "https://spec.example.com/example/v1?unrelated=value")
  { ... }
```

This directive:
- Declares that the document conforms to a spec which can be found at `https://spec.example.com/example/v1`
- Has a base URL of `https://spec.example.com/example`, identifying the specification
- Has a [semver specifier](#semver-specifier) of `v1` identifying the spec version
- Has a query string of `"unrelated=value":
  - This has no effect unless `example` assigns it specific meaning.

## Semantic Versioning

Specifications **should** provide a semantic version number.

### SemVer Specifiers

The final `/`-separated path component **must** be a semver specifier. Semver specifiers take the form `v*major*.*minor*.*patch*-*prerelease*`. The minor, patch, and pre-release specifiers are all optional. Examples:

```
#::[Valid SemVer specifiers]
v1
v1.2
v1.2.3-alpha
v2.2.3-alpha.2
```

### SemVer selection

Processors **should** select the highest available spec implementation which is compatible with the requested version according to the [SemVer 2.0.0](https://semver.org/spec/v2.0.0.html) rules for version compatibility. For example, consider this directive:

```graphql
#::[`@using` version 2.x.y]
schema @using(spec: "https://specs.example.com/example/v2")
```

Upon seeing this directive, processors which support the `https://specs.example.com/example` spec **should** activate a version of their implementation which is compatible with major version 2.

```graphql
#::[`@using` version 3.1.1-alpha]
schema @using(spec: "https://specs.example.com/example/v3.1.1-alpha")
```

This selects versions in the `3.1.1-alpha` prerelease series. For example, a processor may satisfy this requirement by activating version `3.1.1-alpha.2` of `example`.

### Why is versioning in the URL, not a directive argument?

The version is in the URL because when a human reader visits the URL, we would like them to be taken to the documentation for the *version of the specification in use by this document*. Putting the version information in a separate argument to the `@using` directive would prevent this.

### Backus-Naur Form for SemVer specifier

```text
#::[BNF grammar for SemVer specifiers]
â€¹valid specifierâ€º ::= "v" â€¹partial semverâ€º
â€¹partial semverâ€º ::= â€¹majorâ€º
                   | â€¹majorâ€º "." â€¹minorâ€º
                   | â€¹majorâ€º "." â€¹minorâ€º "." â€¹patchâ€º
                   | â€¹majorâ€º "." â€¹minorâ€º "." â€¹patchâ€º "-" â€¹pre-releaseâ€º
```

`major`, `minor`, `patch` and `pre-release` are defined in [the Semantic Versioning 2.0.0 spec](https://semver.org/spec/v2.0.0.html).

</main>
</div>
